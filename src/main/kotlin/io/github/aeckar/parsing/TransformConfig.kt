package io.github.aeckar.parsing

import io.github.aeckar.parsing.dsl.ParserComponentDSL
import io.github.aeckar.parsing.dsl.with

/* ------------------------------ context class ------------------------------ */

/**
 * Configures and returns a transform.
 *
 * Itself represents the captured substring.
 * @see io.github.aeckar.parsing.dsl.mapOn
 * @see io.github.aeckar.parsing.dsl.actionOn
 * @see RichTransform.consumeMatches
 */
@ParserComponentDSL
public class TransformContext<R> @PublishedApi internal constructor(
    private val root: SyntaxTreeNode,   // Stores properties in single object
    state: R
) : Substring {
    private var isChildrenVisited = false
    internal val results = mutableMapOf<Transform<*>, Any?>()

    /** Some state, whose final value is the output. */
    public var state: R = state
        private set

    // Isolate to function in order to apply @PublishedApi annotation
    @PublishedApi
    internal fun setState(value: R) {
        state = value
    }

    /**
     * Returns the output generated by the parser in the context bound to this one using [with]
     * if the transform described by this context cannot accept it.
     * @throws MalformedTransformException the sub-parser was not invoked or failed to match a substring
     */
    @Suppress("UNCHECKED_CAST")
    public fun <R> resultOf(subParser: Parser<R>): R {
        return try {
            results.getValue(subParser) as R
        } catch (_: NoSuchElementException) {
            throw MalformedExpressionException("Result of '$subParser' not found for parser '${root.matcher}'")
        }
    }

    /* ------------------------------ root node properties ------------------------------ */

    public override val substring: String get() = root.substring

    /**
     * The index of the sub-matcher that the [substring] satisfies.
     * @see Match.choice
     */
    public val choice: Int get() = root.choice

    /** Contains nodes for each section of the [substring] captured by any sub-matchers. */
    public val children: List<SyntaxTreeNode> get() = root.children

    /* ------------------------------ descent operations ------------------------------ */

    /**
     * Visits the [children] of the current node, in the order they were matched.
     * @throws MalformedTransformException this function is called more than once within the same scope
     */
    @Suppress("UNCHECKED_CAST")
    public fun descend() {
        if (isChildrenVisited) {
            throw MalformedTransformException("descend() called more than once")
        }
        children.forEach { state = it.walk(state) }
        isChildrenVisited = true
    }

    @PublishedApi
    internal fun finalState(): R {
        if (!isChildrenVisited) {
            descend()
        }
        return state
    }
}
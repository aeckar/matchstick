package io.github.aeckar.parsing.context

import io.github.aeckar.parsing.MalformedTransformException
import io.github.aeckar.parsing.Parser
import io.github.aeckar.parsing.SyntaxTreeNode
import io.github.aeckar.parsing.Transform
import io.github.aeckar.parsing.dsl.ParserComponentDSL
import io.github.aeckar.parsing.dsl.with

/**
 * Configures and returns a transform.
 *
 * Itself represents the captured substring.
 * @see io.github.aeckar.parsing.dsl.mapOn
 * @see io.github.aeckar.parsing.dsl.actionOn
 * @see io.github.aeckar.parsing.RichTransform.consumeMatches
 */
@ParserComponentDSL
public class TransformContext<R> @PublishedApi internal constructor(
    private val root: SyntaxTreeNode,   // Stores properties in single object
    state: R
) {
    private var isChildrenVisited = false
    internal val resultsBySubParser = mutableMapOf<Transform<*>, MutableList<Any?>>()

    /** Some state, whose final value is the output. */
    public var state: R = state
        private set

    // Isolate to function in order to apply @PublishedApi annotation
    @PublishedApi
    internal fun setState(value: R) {
        state = value
    }

    internal fun <R> addResult(subParser: Transform<R>, result: R) {
        if (subParser !in resultsBySubParser) {
            resultsBySubParser[subParser] = mutableListOf(result)
            return
        }
        resultsBySubParser.getValue(subParser) += result
    }

    /**
     * Returns the output generated by the sub-parser in the context bound to this one using [with]
     * if the transform described by this context cannot accept it.
     *
     * If the sub-parser is unnamed,
     *
     * If the sub-parser was never invoked, returns an empty list.
     */
    @Suppress("UNCHECKED_CAST")
    public fun <R> resultsOf(subParser: Parser<R>): List<R> {
        if (subParser == this) {
            return listOf(state) as List<R>
        }
        return object : List<R> by resultsBySubParser[subParser].orEmpty() as List<R> {}    // Prevent modification
    }

    /* ------------------------------ root node properties ------------------------------ */

    public val substring: String get() = root.substring

    /**
     * The index of the sub-matcher that the [substring] satisfies.
     * @see io.github.aeckar.parsing.Match.choice
     */
    public val choice: Int get() = root.choice

    /** Contains nodes for each section of the [substring] captured by any sub-matchers. */
    public val children: List<SyntaxTreeNode> get() = root.children

    /* ------------------------------ descent operations ------------------------------ */

    /**
     * Visits the [children] of the current node, in the order they were matched.
     * @throws io.github.aeckar.parsing.MalformedTransformException this function is called more than once within the same scope
     */
    @Suppress("UNCHECKED_CAST")
    public fun descend() {
        if (isChildrenVisited) {
            throw MalformedTransformException("descend() called more than once")
        }
        children.forEach { state = it.walk(state) }
        isChildrenVisited = true
    }

    @PublishedApi
    internal fun finalState(): R {
        if (!isChildrenVisited) {
            descend()
        }
        return state
    }
}
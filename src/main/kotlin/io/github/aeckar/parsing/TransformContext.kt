package io.github.aeckar.parsing

import io.github.aeckar.parsing.dsl.GrammarDSL
import io.github.aeckar.parsing.dsl.actionUsing
import io.github.aeckar.parsing.dsl.mapUsing
import io.github.aeckar.parsing.dsl.with
import io.github.aeckar.parsing.output.Match
import io.github.aeckar.parsing.output.SyntaxTreeNode

/**
 * Configures and returns a transform.
 *
 * Itself represents the captured substring.
 * @see mapUsing
 * @see actionUsing
 * @see RichTransform.consumeMatches
 */
@GrammarDSL
public class TransformContext<R> @PublishedApi internal constructor(
    private val root: SyntaxTreeNode,   // Stores properties in single object
    state: R
) {
    private var isChildrenVisited = false
    internal val resultsBySubParser = mutableMapOf<Transform<*>, MutableList<Any?>>()

    /** Some state, whose final value is the output. */
    public var state: R = state
        internal set

    internal fun <R> addResult(subParser: Transform<R>, result: R) {
        if (subParser !in resultsBySubParser) {
            resultsBySubParser[subParser] = mutableListOf(result)
            return
        }
        resultsBySubParser.getValue(subParser) += result
    }

    /**
     * Returns the output generated by the sub-parser in the context bound to this one using [with]
     * if the transform described by this context cannot accept it.
     *
     * If the sub-parser is unnamed,
     *
     * If the sub-parser was never invoked, returns an empty list.
     */
    @Suppress("UNCHECKED_CAST")
    public fun <R> resultsOf(subParser: Parser<R>): List<R> {
        if (subParser == this) {
            return listOf(state) as List<R>
        }
        return object : List<R> by resultsBySubParser[subParser].orEmpty() as List<R> {}    // Prevent modification
    }

    /* ------------------------------ root node properties ------------------------------ */

    /** The node containing the target node as a child, if one exists. */
    public val parent: SyntaxTreeNode? get() = root.parent

    /** The substring captured by the target node. */
    public val capture: String get() = root.capture

    /**
     * The index of the sub-matcher that the [capture] satisfies.
     * @see Match.choice
     */
    public val choice: Int get() = root.choice

    /** The index of the [capture] in the original input. */
    public val index: Int get() = root.index

    /** Contains nodes for each section of the [capture] captured by any sub-matchers. */
    public val children: List<SyntaxTreeNode> get() = root.children

    /* ------------------------------ descent operations ------------------------------ */

    /**
     * Visits the [children] of the current node, in the order they were matched.
     * @throws MalformedTransformException this function is called more than once within the same scope
     */
    @Suppress("UNCHECKED_CAST")
    public fun descend() {
        if (isChildrenVisited) {
            throw MalformedTransformException("descend() called more than once")
        }
        children.forEach { state = it.transform(this) }
        isChildrenVisited = true
    }

    internal fun finalState(): R {
        if (!isChildrenVisited) {
            descend()
        }
        return state
    }
}
package io.github.aeckar.parsing

import io.github.aeckar.parsing.dsl.GrammarDSL
import io.github.aeckar.parsing.dsl.actionUsing
import io.github.aeckar.parsing.dsl.mapUsing
import io.github.aeckar.parsing.dsl.with
import io.github.aeckar.parsing.output.ChildNode
import io.github.aeckar.parsing.output.Match
import io.github.aeckar.parsing.output.SyntaxTreeNode

/**
 * Configures and returns a transform.
 *
 * Itself represents the captured substring.
 * @see mapUsing
 * @see actionUsing
 * @see RichTransform.consumeMatches
 */
@GrammarDSL
public class TransformContext<R> @PublishedApi internal constructor(
    private val node: SyntaxTreeNode,
    state: R
) {
    internal val resultsBySubParser = mutableMapOf<Transform<*>, MutableList<Any?>>()

    /** Some state, whose final value is the output. */
    public var state: R = state
        internal set

    /* ------------------------------ node properties ------------------------------ */

    /** The node containing the target node as a child, if one exists. */
    public val parent: SyntaxTreeNode? get() = node.parent

    /** The substring captured by the target node. */
    public val capture: String get() = node.capture

    /**
     * The index of the sub-matcher that the [capture] satisfies.
     * @see Match.choice
     */
    public val choice: Int get() = node.choice

    /** The index of the [capture] in the original input. */
    public val index: Int get() = node.index

    /** Contains nodes for each section of the [capture] captured by any sub-matchers. */
    @Suppress("UNCHECKED_CAST")
    public val children: List<ChildNode> = node.children.map { ChildNode(it, this as TransformContext<Any?>) }

    /* ----------------------------------------------------------------------------- */

    internal fun <R> addResult(subParser: Transform<R>, result: R) {
        if (subParser !in resultsBySubParser) {
            resultsBySubParser[subParser] = mutableListOf(result)
            return
        }
        resultsBySubParser.getValue(subParser) += result
    }

    /**
     * Returns the output generated by the sub-parser in the context bound to this one using [with]
     * if the transform described by this context cannot accept it.
     *
     * If the sub-parser is unnamed,
     *
     * If the sub-parser was never invoked, returns an empty list.
     */
    @Suppress("UNCHECKED_CAST")
    public fun <R> resultsOf(subParser: Parser<R>): List<R> {
        if (subParser == this) {
            return listOf(state) as List<R>
        }
        return object : List<R> by resultsBySubParser[subParser].orEmpty() as List<R> {}    // Prevent modification
    }

    /**
     * Visits the [children] of the current node that have not been visited yet, in the order they were matched.
     *
     * If all children have been visited, this function does nothing.
     */
    public fun visitRemaining() {
        children.forEach { child ->
            if (!child.isVisited) {
                child.visit()
            }
        }
    }
}
package io.github.aeckar.parsing.output

import io.github.aeckar.parsing.GrammarContext
import io.github.aeckar.parsing.Grammar
import io.github.aeckar.parsing.Matcher
import io.github.aeckar.parsing.Parser
import io.github.aeckar.parsing.RichMatcher
import java.util.*

/**
 * Provides a scope to describe how an instance of type [R] should be modified when a [SyntaxTreeNode]
 * produced by a specific [Matcher] is visited when walking the completed syntax tree.
 */
public typealias TransformScope<R> = TransformContext<R>.() -> Unit

/**
 * Configures and returns a transform.
 *
 * Itself represents the captured substring.
 * @see SyntaxTreeNode.transform
 * @see io.github.aeckar.parsing.parse
 */
public class TransformContext<R> @PublishedApi internal constructor(
    internal val actions: TransformMap<*>,
    private val node: SyntaxTreeNode,
    state: R
) : GrammarContext() {
    internal val resultsBySubMatcher = mutableMapOf<RichMatcher, MutableList<Any?>>()

    /** Some state, whose final value is the output. */
    public var state: R = state
        internal set

    /* ------------------------------ node properties ------------------------------ */

    /** The node containing the target node as a child, if one exists. */
    public val parent: SyntaxTreeNode? get() = node.parent

    /** The substring captured by the target node. */
    public val capture: String get() = node.capture

    /**
     * The index of the sub-matcher that the [capture] satisfies.
     * @see Match.choice
     */
    public val choice: Int get() = node.choice

    /** The index of the [capture] in the original input. */
    public val index: Int get() = node.index

    /** Contains nodes for each section of the [capture] captured by any sub-matchers. */
    @Suppress("UNCHECKED_CAST")
    public val children: List<ChildNode> = node.children.map { ChildNode(it, this as TransformContext<Any?>) }

    /* ----------------------------------------------------------------------------- */

    internal fun <R> addResult(subParser: RichMatcher, result: R) {
        if (subParser !in resultsBySubMatcher) {
            resultsBySubMatcher[subParser] = mutableListOf(result)
            return
        }
        resultsBySubMatcher.getValue(subParser) += result
    }

    /**
     * Returns the output generated by the sub-parser in the context bound to this one using [with]
     * if the transform described by this context cannot accept it.
     *
     * If the sub-parser is unnamed,
     *
     * If the sub-parser was never invoked, returns an empty list.
     */
    @Suppress("UNCHECKED_CAST")
    public fun <R> resultsOf(matcher: Matcher): List<R> {
        if (matcher == this) {
            return listOf(state) as List<R>
        }
        return Collections.unmodifiableList(resultsBySubMatcher[matcher].orEmpty()) as List<R>
    }

    /** Calls [resultsOf][TransformContext.resultsOf] with the [start][Grammar.start] matcher of the given parser. */
    public fun <R> resultsOf(parser: Parser<R>): List<R> {
        return resultsOf(parser.start)
    }

    /**
     * Visits the [children] of the current node that have not been visited yet, in the order they were matched.
     *
     * If all children have been visited, this function does nothing.
     */
    public fun visitRemaining() {
        children.forEach { child ->
            if (!child.isVisited) {
                child.visit()
            }
        }
    }
}